lambdaHandler.py – Main Handler
In lambdaHandler.py, you’ll have functions that handle Textract for each image stage (Original, Sharpened, and Heatmap), plus a workflow to call each function, extract VINs, and save them.

Here’s the full code for lambdaHandler.py:

python
Copy code
from collections import defaultdict
import os
from threading import Thread
from typing import Dict, Optional, Union
import uuid
from image_util import apply_heatmap, sharpen_image
from local_logger import log_debug, log_info, log_fatal, log_warn
from eventIngestor import EventIngestor
from clientManager import Boto3ClientManager
from messaging import MessagingOperations, StageTypeStr
from mainLogic import MainLogic, build_textract_result
from kvstore import (
    GLOBAL_STATE_ID,
    DBStateKeyConstants,
    add_event_state_to_state_store,
    clean_up,
    create_pickle,
    get_global_state,
    get_global_state_values,
    set_global_state_value,
)
from textract_types import S3Object
from util import build_table

def original_image_textract(ingestor, client_manager):
    # Initialize MainLogic for the original image
    main_logic = MainLogic(
        ingestor,
        client_manager,
        bucket_name=os.environ["BUCKET_NAME"],
        object_name=MessagingOperations.build_object_full_name(StageTypeStr.ORIGINAL, os.environ["OUTPUT_FOLDER"]),
    )
    # Upload the original image to S3
    main_logic.save_to_s3(DBStateKeyConstants.ORIGS3IMAGEFULLPATH)
    # Run Textract and return the result
    response = do_textract(S3Object(main_logic.bucket_name, main_logic.object_name), client_manager)
    return build_textract_result(response)

def sharpened_image_textract(ingestor, client_manager):
    main_logic = MainLogic(
        ingestor,
        client_manager,
        bucket_name=os.environ["BUCKET_NAME"],
        object_name=MessagingOperations.build_object_full_name(StageTypeStr.SHARPENED, os.environ["OUTPUT_FOLDER"]),
    )
    main_logic.save_to_s3(DBStateKeyConstants.SHARPENEDS3IMAGEFULLPATH)
    response = do_textract(S3Object(main_logic.bucket_name, main_logic.object_name), client_manager)
    return build_textract_result(response)

def heatmap_image_textract(ingestor, client_manager):
    main_logic = MainLogic(
        ingestor,
        client_manager,
        bucket_name=os.environ["BUCKET_NAME"],
        object_name=MessagingOperations.build_object_full_name(StageTypeStr.HEATMAP, os.environ["OUTPUT_FOLDER"]),
    )
    main_logic.save_to_s3(DBStateKeyConstants.HEATMAPS3IMAGEFULLPATH)
    response = do_textract(S3Object(main_logic.bucket_name, main_logic.object_name), client_manager)
    return build_textract_result(response)

# Main workflow to extract VINs from each image stage
def process_images_and_store_vins(ingestor, client_manager):
    # Call each Textract function to process each image type and extract VIN values
    vin_from_original = original_image_textract(ingestor, client_manager).words_response.vin_value
    vin_from_sharpened = sharpened_image_textract(ingestor, client_manager).words_response.vin_value
    vin_from_heatmap = heatmap_image_textract(ingestor, client_manager).words_response.vin_value

    # Save each VIN value in global state for access later (for email, logs, etc.)
    set_global_state_value(os.environ[GLOBAL_STATE_ID], DBStateKeyConstants.VIN_FROM_ORIGINAL_IMAGE.value, vin_from_original)
    set_global_state_value(os.environ[GLOBAL_STATE_ID], DBStateKeyConstants.VIN_FROM_SHARPENED_IMAGE.value, vin_from_sharpened)
    set_global_state_value(os.environ[GLOBAL_STATE_ID], DBStateKeyConstants.VIN_FROM_HEATMAP_IMAGE.value, vin_from_heatmap)
Explanation:
We define functions (original_image_textract, sharpened_image_textract, and heatmap_image_textract) to process each image type and extract VINs.
The process_images_and_store_vins function is a workflow that calls each processing function, retrieves the VINs, and stores them in global_state.
2. util.py – Building the Email Content
In util.py, create an email content function that uses the VIN values stored in global_state and adds them to an HTML table for emailing.

Here’s the complete code for the email content function in util.py:

python
Copy code
from kvstore import get_global_state_value  # Ensure this import is present to access global_state values
from util import build_table

def build_vin_email_content():
    # Create a dictionary with VIN data retrieved from the global state
    vin_data = {
        "Original Image VIN": get_global_state_value(os.environ[GLOBAL_STATE_ID], DBStateKeyConstants.VIN_FROM_ORIGINAL_IMAGE.value),
        "Sharpened Image VIN": get_global_state_value(os.environ[GLOBAL_STATE_ID], DBStateKeyConstants.VIN_FROM_SHARPENED_IMAGE.value),
        "Heatmap Image VIN": get_global_state_value(os.environ[GLOBAL_STATE_ID], DBStateKeyConstants.VIN_FROM_HEATMAP_IMAGE.value)
    }
    
    # Use build_table to generate HTML content for email
    html_content = build_table(for_dict=vin_data, header="VIN Information")
    return html_content
3. Using the Email Content in lambdaHandler.py or Your Email Function
In lambdaHandler.py, or wherever you handle sending emails, call build_vin_email_content() to get the HTML content for the email.

Example:

python
Copy code
# Assuming you have a function to send HTML emails
html_content = build_vin_email_content()
subject = "VIN Information from Different Image Stages"
send_email(html_content, subject)  # Replace with your email-sending function
Summary of Files
lambdaHandler.py:

Adds functions to process Original, Sharpened, and Heatmap images.
Contains a workflow (process_images_and_store_vins) that calls each Textract function, extracts VINs, and saves them in global_state.
util.py:

Contains build_vin_email_content() to pull VIN values from global_state and create HTML email content.
This should give you a complete setup for processing images, extracting VINs, and emailing the results in a structured HTML table. Let me know if you need any more clarification on any part!